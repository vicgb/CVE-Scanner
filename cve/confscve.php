<?php

require_once '../vendor/autoload.php';
require '../controllers/conexionCVE.php';



class CVE
{

    public $app;



    //Saca todas las confs, incluyendo los :*:*:*. Es necesario para sacar el summary.
    public function getconf($app)
    {

        $arrayconfs = array();
        $cursor = $this->peticionMongo();
        foreach ($cursor as $doc) {
            $confs = (array) $doc['vulnerable_configuration'];

            for ($i = 0; $i < count($confs); $i++) {
                $cond = $this->encontrarString($app, $confs[$i]);

                if ($cond == true) {

                    $arr = array_unique($confs, SORT_STRING);
                    $confsapp = array_reverse($arr);
                   

                    for ($j = 0; $j < count($confsapp); $j++) {


                        $pos = strpos($confsapp[$j], $app);

                        if (is_int($pos)) {
                            array_push($arrayconfs, $confsapp[$j]);
                        } else {
                            continue;
                        }
                    }
                   return $arrayconfs;
                }
            }
        }
    }

    //Sacamos las confs del CVE de una app, eliminando lo redundante. 
    public function parsearconfs($app)
    {
        $arrayconfs = $this->getconf($app);
        $arrayconfs2 = array();

        for ($j = 0; $j < count($arrayconfs); $j++) {
            $pos2 = strpos($arrayconfs[$j], ':*');
            if (is_int($pos2)) {
                array_push($arrayconfs2, substr($arrayconfs[$j], 0, $pos2));
            } else {
                continue;
            }
        }
        return $arrayconfs2;
    }

    function getSummary($cveconf)
    {
        global $collection;

        $cursor = $collection->find(array('vulnerable_configuration' => $cveconf));

        foreach ($cursor as $doc) {
            $summary = (array) $doc['summary'];



            return $summary;
        }
    }


    //Para sacar las versiones que aparecen en el resumen. Si hay varias, devolvemos 0.
    public function getSummaryVersion($summary)
    {

        $summary_explode = explode(" ", $summary[0]);


        for ($i = 0; $i < count($summary); $i++) {


            //Todos los diferentes escenarios que hay
            if (in_array('prior', $summary_explode)) {

                $num = substr_count($summary[$i], 'prior', 0);
                if ($num == 1) {
                    $prior = array_search('prior', $summary_explode);
                    $version = $summary_explode[$prior + 2];
                    return $version;
                } else {
                    return 0;
                }
            } elseif (in_array('Prior', $summary_explode)) {

                $num = substr_count($summary[$i], 'Prior', 0);
                if ($num == 1) {

                    $Prior = array_search('Prior', $summary_explode);
                    $version = $summary_explode[$Prior + 2];

                    return $version;
                } else {
                    return 0;
                }
            } elseif (in_array('<', $summary_explode)) {

                $num = substr_count($summary[$i], '<', 0);
                if ($num === 1) {
                    $before = array_search('<', $summary_explode);
                    $version = $summary_explode[$before + 1];
                    return intval($version);
                } else {
                    return 0;
                }

            } elseif (in_array('before', $summary_explode)) {
                $num = substr_count($summary[$i], 'before', 0);
                if ($num  === 1) {
                    $before2 = array_search('before', $summary_explode);
                    $version = $summary_explode[$before2 + 1];

                    return $version;
                } else {
                    return 0;
                }
            }
        }
    }




    //Para solucionar problema con 'AVG'.
    public function getLongConf($app)
    {
        $arrayconfs2 = array();
        
        $cursor = $this->peticionMongo();
        foreach ($cursor as $doc) {
            $confs = (array) $doc['vulnerable_configuration'];

            for ($i = 0; $i < count($confs); $i++) {
                $cond = $this->encontrarString($app, $confs[$i]);

                if ($cond == true) {
                    $arr = array_unique($confs, SORT_STRING);
                    $confsapp = array_reverse($arr);
                
                    for ($j = 0; $j < count($confsapp); $j++) {
                        $pos2 = strpos($confsapp[$j], ':*');
                        if (is_int($pos2)) {
                            array_push($arrayconfs2, substr($confsapp[$j], 0, $pos2));
                        } else {
                            continue;
                        }
                    }
                    return $arrayconfs2;
                 
                } else {
                    continue;
                }
            }
        }
    }

    function peticionMongo()
    {

        global $collection;



        $mongo = new conexionCVE();
        $mongo->__construct();

        $filter  = ['$sort' => ['last-modified' => -1, 'Published' => -1]];
        $options = ['allowDiskUse' => true];  //Evitamos problema de limite de memoria

        $cursor = $collection->aggregate(array($filter), array($options));

        return $cursor;
    }



    //Funciones auxiliares

    public function getLastCVELongConf($app)
    {
        $arr = $this->getconf($app);
        $last_long_cve = $arr[0];

        return $last_long_cve;
    }


    public function getApp($conf)
    {

        $appconf = explode(":", $conf);
        $app = $appconf[4];
        return $app;
    }


    public function getLastVersionCVE($conf)
    {

        $version_conf = explode(":", $conf);
        $version = $version_conf[5];

        return $version;
    }




    public function getPlatform($conf)
    {

        //Devuelve la plataforma a la que se refieren esas confs
        $platformconf = explode(":", $conf);
        $platform = $platformconf[3];
        return $platform;
    }



    private function encontrarString($string, $conf)
    {
        if(!empty($conf)){
        $appconf = explode(":", $conf);
        $app = $appconf[4];
        $aux = $appconf[3];

        $resultado = strpos($app, $string);
        $resultado2 = strpos($aux, $string);
        
        if ($resultado !== FALSE) {
            return true;
        }elseif ($resultado2 !== FALSE){
            return true;
        }else{
            return false;
        }
    }else{
       print("Ha ocurrido un error. Pruebe de nuevo");
    }

    }
    public function getLastCVEConf($app)
    {

        $array = $this->parsearconfs($app);
        $last_cve = $array[0];


        return $last_cve;
    }



    
}


























